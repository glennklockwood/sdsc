#!/usr/bin/env perl
################################################################################
# ibrun - SDSC's re-implementation of the ibrun wrapper for the various MPI
#         launchers
#
# Glenn K. Lockwood, San Diego Supercomputer Center             December 2013
################################################################################

use strict;
use warnings;
use Sys::Hostname;
use Getopt::Long;
use POSIX;

use constant CONTACT => 'Contact help@xsede.org for additional assistance.';
use constant ENABLE_DEBUGGING => 1;

our $options; 

### Pull in default options from the resource manager
$options->{sys_rm}      = 'Torque';
$options->{rm_nodefile} = $ENV{PBS_NODEFILE};
$options->{rm_num_nodes}= $ENV{PBS_NUM_NODES};
$options->{rm_ppn}      = $ENV{PBS_NUM_PPN};
$options->{rm_jobid}    = $ENV{PBS_JOBID};
$options->{rm_num_ranks}   = $options->{rm_num_nodes} * $options->{rm_ppn};
$options->{mpi_srq_size}        = 2048;
$options->{mpi_default_timeout} = 23;

$options->{env_hacks}->{mvapich2} = {
    MV2_USE_UD_HYBRID => 0,
    MV2_USE_OLD_BCAST => 1,
    MV2_HOMOGENEOUS_CLUSTER => 0,
    MV2_USE_HUGEPAGES => 0,
    MV2_DEFAULT_TIME_OUT => $options->{mpi_default_timeout},
};
$options->{env_hacks}->{openmpi} = {
    OMPI_MCA_btl => 'self,sm,openib',
    OMPI_MCA_btl_openib_use_srq => 1,
    OMPI_MCA_btl_openib_ib_timeout => $options->{mpi_default_timeout},
    OMPI_MCA_btl_openib_use_rd_max => $options->{mpi_srq_size},
};
$options->{env_hacks}->{mpich} = {
    # nothing here
};

### Machine-specific stuff
{
    my $hostname = hostname();
    if ( $hostname =~ m/^(gcn-|gordon-)/ ) { 
        $options->{sys_pps}         = 8;    # sockets per node
        $options->{sys_ppn}         = 16;   # cores per node
        $options->{sys_max_nodes}   = 128;  # max nodes per job
    }
    elsif ( $hostname =~ m/^trestles-/ ) {
        $options->{sys_pps}         = 8;
        $options->{sys_ppn}         = 32;
        $options->{sys_max_nodes}   = 32;
    }
    elsif ( $hostname =~ m/^tscc-/ ) {
        $options->{sys_pps}         = 8;
        $options->{sys_ppn}         = 16;
        $options->{sys_max_nodes}   = 9999999;
    }
    else {
        # bailout( -1, "ERROR: ibrun is running on an unknown system.  " . CONTACT );
        $options->{sys_pps}         = 8;
        $options->{sys_ppn}         = 32;
        $options->{sys_max_nodes}   = 32;
    }
}

### Let command-line options override the defaults defined above
$options = get_options( \@ARGV );
$options->{cmd} = shift(@ARGV);
$options->{cmd_args} = \@ARGV;

### Determine MPI stack to be used
$options->{mpi_stack} = "openmpi";
$options->{mpi_launcher} = "mpirun_rsh";

### Build the nodefile for this MPI job
gen_nodefile( );

### Construct the appropriate MPI launcher command line
my $cmd_string = gen_mpirun_cmd( $options );

#unlink($options->{nodefile});           # delete the nodefile
printf( "Nodefile is %s\n", $options->{nodefile} );
printf( "Command string is [%s] with args [%s]\n", 
    $cmd_string, 
    join(' ', @{$options->{cmd_args}}) );
#system( $cmd_string, @{$options->{cmd_args}} );

################################################################################
### load_nodefile: Load nodelist from nodefile into an array and return it
################################################################################
sub load_nodefile
{
    my $nodefile = shift;
    open (NODEFILE, $nodefile) or bailout( 1, "Unable to open nodefile $nodefile\n");

    my @nodelist;
    
    while ( my $line = <NODEFILE> )
    {
        $line =~ m/^\s*(\S+)\s*$/;
        push( @nodelist, $1 );
    }
    return @nodelist;
}

################################################################################
### gen_nodefile: Rebuild a nodefile based on user input, return its location.
###     This subroutine assumes that num_nodes, npernode are either well-
###     defined, or npernode is negative, num_nodes is well-defined and npernode
###     needs to be recalculated here
################################################################################
sub gen_nodefile
{
    use File::Temp;

    ### Load nodelist into an array
    my @nodelist = load_nodefile( $options->{rm_nodefile} );
    $options->{nodelist} = \@nodelist;

    ### If the user is running a normal job (each MPI rank corresponds to a
    ### single MPI process on a single core), just bypass all this extra 
    ### work and just use the nodefile from the resource manager (rm_nodefile)
    if ( ($options->{num_nodes} * $options->{npernode}) == ($options->{rm_num_nodes} * $options->{rm_ppn}) )
    {
        dprintf("no hostfile mod needed\n");
        $options->{nodefile} = $options->{rm_nodefile};
        $options->{tpr} = 1;
        return;
    }
    
    ### Otherwise, we need to reconstruct the nodefile.  Start by creating a new
    ### temporary file...
    my ($fh, $filename) = File::Temp::tempfile();

    my $npernode = $options->{npernode};
    my @my_npernode;
    $options->{my_npernode} = \@my_npernode;

    #### Convert nodelist into a list of unique nodes with order preserved
    my @unique_nodes;
    foreach my $node ( @nodelist ) {
        push( @unique_nodes, $node ) unless grep {$_ eq $node} @unique_nodes;
    }
    $options->{unique_nodes} = \@unique_nodes;

    ### Make sure the nodelist contains the same number of nodes as the 
    ### resource manager says it should contain
    if ( scalar(@unique_nodes) != $options->{rm_num_nodes} ) {
        close($fh);
        bailout( -5, sprintf( "ERROR: assert failed: #nodes (%d) in nodefile "
            ."(%s) inconsistent with nodecount (%d) from %s\n",
            scalar(@unique_nodes),
            $options->{rm_nodefile},
            $options->{rm_num_nodes} ),
            $options);
    }

    ### Make sure the user isn't requesting more nodes that he or she was given
    if ( scalar(@unique_nodes) < $options->{num_nodes} )
    {
        close($fh);
        bailout( 4, 
            sprintf("ERROR: Your MPI job requested %d nodes but %s only provided %d.\n",
            $options->{num_nodes}, $options->{sys_rm}, scalar(@unique_nodes) ),
            $options);
    }

    # -N supercedes the number of nodes given by the batch system
    my $nodes_to_use = $options->{num_nodes};

    # Positive npernode means npernode divides evenly into num_nodes.  Just 
    # print $npernode copies per node into the new nodefile.
    if ( $npernode > 0 )
    {
        @my_npernode = ($npernode) x $options->{num_nodes};
        $options->{tpr} = $options->{rm_ppn} / $npernode;
    }
    # Negative npernode means npernode does not divide evenly into num_nodes.
    # We need to figure out what npernode should be on each node.  This also
    # suggests that the job geometry is not meant to logically map to the 
    # available cores per node, so we assume threads per rank (tpr) = 1
    elsif ( $npernode < 0 )
    {
        dprintf( "hacking hostfile...\n" );
        $npernode = abs($npernode);
        @my_npernode = ($npernode) x $options->{num_nodes};
        my $num_ranks = $options->{num_ranks};
        my $num_nodes = $options->{num_nodes};
        
        # figure out which nodes need to take up the slack
        dprintf( "remainder is %d = %d - %d * %d\n", 
            ($num_ranks - $num_nodes * $npernode),
            $num_ranks,
            $num_nodes,
            $npernode );
        foreach my $i ( 0 .. ($options->{num_nodes}-1) )
        {
            $my_npernode[$i]++ if $i < ($num_ranks - $num_nodes * $npernode);
        }
        $options->{tpr} = 1;
    }
    ### At this point the threads-per-rank should be known.  Check its sanity:
    if ( $ENV{OMP_NUM_THREADS} && $ENV{OMP_NUM_THREADS} != $options->{tpr} )
    {
        printf( STDERR 
            "WARNING: Your job geometry appears to suggest that you want %d "
            ."threads per MPI rank, but your OMP_NUM_THREADS is %d.  This will "
            ."cause thread binding to be disabled.\n",
            $options->{tpr}, $ENV{OMP_NUM_THREADS} );
        $options->{tpr} = -1;
    }

    ### Convert our nodelist and my_npernode into nodefiles
    dprintf("Running on %d unique nodes\n", $nodes_to_use);
    foreach my $i ( 0 .. ($nodes_to_use-1) )
    {
        dprintf( "Will place %d ranks on %s with %d threads each\n", 
            $my_npernode[$i], 
            $unique_nodes[$i], 
            $options->{tpr} );
        foreach ( 1 .. $my_npernode[$i] )
        {
            print $fh $unique_nodes[$i] . "\n";
        }
    }
    close($fh);

    ### Now set most sensible binding policy and level based on job geometry
    if ( $options->{tpr} == 1 ) {
        $options->{def_binding_policy}  = 'scatter';    # best memory bandwidth
        $options->{def_binding_level}   = 'core';
    }
    elsif ( $options->{tpr} == $options->{sys_pps} ) {
        $options->{def_binding_policy}  = 'scatter';
        $options->{def_binding_level}   = 'socket';
    }
    else {
        $options->{def_binding_policy}  = 'none';
        $options->{def_binding_level}   = 'off';
    }

    ### Set these recommended settings if user hasn't overridden them
    if ( !$options->{binding_policy} ) {
        $options->{binding_policy} = $options->{def_binding_policy};
    }
    if ( !$options->{binding_level} ) {
        $options->{binding_level} = $options->{def_binding_level};
    }

    dprintf( "MPI binding policy: %s/%s for %d threads per node (%d cores per socket)\n", 
        $options->{binding_policy},
        $options->{binding_level},
        $options->{tpr},
        $options->{sys_pps} );

    $options->{nodefile} = $filename;
    return;
}

################################################################################
### gen_mpirun_cmd: Generate the actual "mpirun -n X ..." line to be executed
################################################################################
sub gen_mpirun_cmd
{
    my $launch_cmd = "echo 'ERROR: No MPI launcher found' >&2; echo ";

    my $mpi_stack = $options->{mpi_stack};

    # Load the env variables we want to hack in for our specific MPI stack
    my $env_hacks;
    if ( $options->{env_hacks}->{$mpi_stack} ) { 
        $env_hacks = $options->{env_hacks}->{$mpi_stack};
    }

    ### MVAPICH2 ###############################################################
    if ( $options->{mpi_stack} eq "mvapich2" )
    {
        # Generate binding policy settings
        if ( $options->{binding_policy} eq 'none'
        ||   $options->{binding_level} eq 'none' ) {
            $env_hacks->{MV2_ENABLE_AFFINITY} = 0;
        }
        else {
            if ( $options->{binding_policy} eq 'scatter' ) {
                $env_hacks->{MV2_CPU_BINDING_POLICY} = 'scatter';
            }
            elsif ( $options->{binding_policy} eq 'compact' ) {
                $env_hacks->{MV2_CPU_BINDING_POLICY} = 'bunch';
            }
            else {
                $env_hacks->{MV2_ENABLE_AFFINITY} = 0;
            }
    
            if ( $options->{binding_level} eq 'socket' ) {
                $env_hacks->{MV2_CPU_BINDING_LEVEL} = 'socket';
            }
            elsif ( $options->{binding_level} eq 'core' ) {
                $env_hacks->{MV2_CPU_BINDING_LEVEL} = 'core';
            }
            else {
                $env_hacks->{MV2_ENABLE_AFFINITY} = 0;
            }
        }

        # Build mpirun command and environment variable injection
        if ( $options->{mpi_launcher} eq 'mpirun_rsh' )
        {

            $launch_cmd = "mpirun_rsh";
            $options->{mpirun_switches} .= sprintf( "-np %d -hostfile %s ",
                $options->{num_ranks}, $options->{nodefile} );
            $options->{mpirun_switches} .= gen_env($env_hacks);
        }
        elsif ( $options->{mpi_launcher} eq 'mpiexec.hydra' )
        {
            $launch_cmd = gen_env($env_hacks);
            $launch_cmd .= "mpiexec.hydra";
            $options->{mpirun_switches} .= sprintf( "-np %d -hostfile %s ",
                $options->{num_ranks}, $options->{nodefile} );
        }
        else
        {
            bailout( 2, "Unknown/undefined MPI launcher\n", $options );
        }
    }

    ### OPENMPI ################################################################
    elsif ( $options->{mpi_stack} eq "openmpi" )
    {
        # Generate binding policy settings
        if ( $options->{binding_policy} eq 'none'
        ||   $options->{binding_level} eq 'none' ) {
            $options->{mpirun_switches} .= '--bind-to-none ' ;
        }
        else {
            if ( $options->{binding_policy} eq 'scatter' ) {
                $options->{mpirun_switches} .= '--bysocket ' ;
            }
            elsif ( $options->{binding_policy} eq 'compact' ) {
                $options->{mpirun_switches} .= '--bycore ';
            }
            else {
                $options->{mpirun_switches} .= '--bind-to-none ';
            }
    
            if ( $options->{binding_level} eq 'socket' ) {
                $options->{mpirun_switches} .= '--bind-to-socket ';
            }
            elsif ( $options->{binding_level} eq 'core' ) {
                $options->{mpirun_switches} .= '--bind-to-core ';
            }
            else {
                $options->{mpirun_switches} .= '--bind-to-none ';
            }
        }

        # Build mpirun command and environment variable injection
        $launch_cmd = gen_env($env_hacks);
        $launch_cmd .= "orterun";
        $options->{mpirun_switches} .= sprintf( "-n %d -machinefile %s ",
            $options->{num_ranks}, $options->{nodefile} );
    }

    ### MPICH2 #################################################################
    elsif ( $options->{mpi_stack} eq "mpich2" )
    {
        bailout( 1, "This feature is not yet available.\n", $options )
    }
    else
    {
        bailout(2, sprintf( "Unknown MPI stack '%s'.  %s\n",
            ($options->{mpi_stack} ? $options->{mpi_stack} : "????"), CONTACT),
            $options );
    }
    return sprintf( "%s %s %s",
        $launch_cmd,
        $options->{mpirun_switches},
        $options->{cmd} );
}

################################################################################
### gen_env: Subroutine to turn a hash into an environment variable assignment 
### string.  Doesn't overwrite values from the hash is the user already set them
################################################################################
sub gen_env
{
    my $hash = shift;
    %$hash = ( $options->{ibrun_env}, %$hash ) if $options->{ibrun_env};
    my $output = "";

    ### only set environment variables that user hasn't already set
    foreach my $key ( keys(%$hash) ) {
        unless ( $ENV{$key} ) {
            $output .= sprintf( "%s=%s ", $key, $hash->{$key} );
        }
    }
    return $output;
}

################################################################################
### get_options: Parse command line input and check for errors.  This will be 
### called AFTER the resource manager's paramaters have already been loaded into
### the options hash.
################################################################################
sub get_options
{
    my $argv = shift;
    my $old_options = $options;
    my %new_options;
    use Getopt::Long;
    Getopt::Long::Configure( "require_order", "no_ignore_case", 
                            "auto_version", "auto_help", "no_auto_abbrev" );
    if ( @$argv > 0 ) 
    {
        GetOptions(
            "o=i"           =>  \$new_options{nodefile_offset},
            "no=i"          =>  \$new_options{node_offset},
            "N=i"           =>  \$new_options{num_nodes},
            "n|np=i"        =>  \$new_options{num_ranks}, 
            "npernode=i"    =>  \$new_options{npernode},
            "switches=s"    =>  \$new_options{mpirun_switches},
            "binding-policy=s"  =>  \$new_options{binding_policy},
            "binding-level=s"   =>  \$new_options{binding_level},
        );
    }

    ### Check the consistency of user-provided options before doing anything
    #
    # Hybrid jobs (those which do not run one MPI rank per core) can be 
    # specified in several ways:
    #
    #   1. Specifying -N and -n (a la Slurm)
    #   2. Specifying -N and -npernode (a la OpenMPI)
    #   3. Just -n (let the RM pick up the -N)
    #   4. Just -npernode (let the RM pick up the -N)
    #
    #   Thus, if neither -npernode nor -n are provided, this is not a hybrid 
    # job.  In all cases, rm_num_ranks should probably be ignored.  As long as
    # we can gaurantee that num_nodes and npernode are defined by the end of
    # get_options(), we can calculate num_ranks.
    #
    #   In the event that npernode is negative (i.e., not all nodes have the
    # same loading due to num_ranks%npernode != 0), num_ranks is already 
    # defined by the user so it would be safe to carry that value forward
    # without recalculating.
    #
    if ( $new_options{num_ranks}
    &&   $new_options{num_nodes}
    &&   $new_options{npernode}
    &&   ($new_options{num_nodes}*$new_options{npernode}) != $new_options{num_ranks} ) {
        bailout( 1, "ERROR: Either provide -N and -n OR -N and --npernode\n" );
    }
    if ( $new_options{npernode}
    &&   $new_options{num_ranks} )
    {
        bailout( 1, "ERROR: Either provide -n OR --npernode, but not both\n" );
    }

    # Check offset arguments to maintain compatibility with TACC's ibrun 
    # implementation.  Also added a per-node offset
    if ( $new_options{nodefile_offset}
    && ( ($new_options{num_ranks} && $new_options{nodefile_offset} >= $new_options{num_ranks})
    ||   $new_options{nodefile_offset} < 0) ) {
        bailout( 1, "ERROR: Your nodefile offset (-o) must be between 0 and (n-1).\n" );
    }
    if ( $new_options{node_offset}
    && ( ( $new_options{num_nodes}
    &&   $new_options{node_offset} >= $new_options{num_nodes})
    ||   $new_options{node_offset} < 0 ) ) {
        bailout( 1, "ERROR: Your node offset (-no) must be between 0 and (N-1).\n" );
    }

    # Make sure user did not entire anything that is numerically nonsensical
    if ( $new_options{num_nodes} && $new_options{num_nodes} <= 0 ) {
        bailout( 1, "ERROR: Your number of nodes (-N) must be greater than zero.\n" );
    }
    if ( $new_options{num_ranks} && $new_options{num_ranks} <= 0 ) {
        bailout( 1, "ERROR: Your number of ranks (-n) must be greater than zero.\n" );
    }
    if ( $new_options{npernode} && $new_options{npernode} <= 0 ) {
        bailout( 1, "ERROR: Your ranks per node (--npernode) must be greater than zero.\n" );
    }

    # Check for a valid binding policy/level
    if ( $new_options{binding_policy} ) {
        my %valid = (
            'scatter'   => 'scatter',
            'compact'   => 'compact',
            'bunch'     => 'compact',
            'none'      => 'none',
            'off'       => 'none', );
        if ( !$valid{$new_options{binding_policy}} ) {
            bail(1, "ERROR: Invalid binding policy.  Valid policies are "
            . join( ' ', reverse(keys(%valid)) ) );
        }
        else {
            $new_options{binding_policy} = $valid{$new_options{binding_policy}};
        }
    }
    if ( $new_options{binding_level} ) {
        my %valid = (
            'core'      => 'core',
            'socket'    => 'socket',
            'none'      => 'none',
            'off'       => 'none');
        if ( !$valid{$new_options{binding_level}} ) {
            bail(1, "ERROR: Invalid binding level.  Valid level are "
            . join( ' ', reverse(keys(%valid)) ) );
        }
        else {
            $new_options{binding_level} = $valid{$new_options{binding_level}};
        }
    }


    # Merge in the user-provided values with the pre-set values.  Overwrite old
    # pre-set values with user-provided when duplicates occur.
    my %options = ( %$old_options, %new_options );


    ### If user did not specify certain parameters, copy the values from what
    ### the resource manager (rm) provided
    # this job should skip the first X entries in the nodefile
    if ( !$options{nodefile_offset} ) { 
        dprintf( "Using default nodefile_offset for now...\n" );
        $options{nodefile_offset} = 0; 
    }

    # this job should skip the first X unique nodes in the nodefile
    if ( !$options{node_offset} ) {
        dprintf( "Using default node_offset for now...\n" );
        $options{node_offset} = 0;
    }

    # how many nodes the job will use
    if ( !$options{num_nodes} ) {
        dprintf( "Using default num_nodes for now...\n" );
        $options{num_nodes} = $options{rm_num_nodes}
    }

    # how many MPI ranks total the job will use
    if ( !$options{num_ranks} ) {
        if ( $options{num_nodes} == $options{rm_num_nodes} ) {
            dprintf( "Using default num_ranks for now...\n" );
            $options{num_ranks} = $options{rm_num_ranks};
        }
        # if user provides -N but nothing else, assume she wants all all cores
        # on those nodes (e.g., for a node_offset job)
        elsif ( !$options{npernode} ) {
            dprintf( "Assuming num_ranks = num_nodes * rm_ppn\n" );
            $options{num_ranks} = $options{num_nodes} * $options{rm_ppn};
        }
    }

    # how many MPI ranks per node the job will use.  If this is NEGATIVE, then 
    # the division is uneven and the node breakdown requires a lot more logic,
    # so flag the npernode parameter and let gen_hostfile() do that
    my $remainder = $options{num_ranks} % $options{num_nodes};
    if ( !$options{npernode} )
    {
        dprintf( "Calculating proper npernode since -npernode wasn't defined...\n" );
        if ( $remainder == 0 ) {
            $options{npernode} = $options{num_ranks} / $options{num_nodes};
        }
        else {
            $options{npernode} = -1 * floor($options{num_ranks} 
                                    / $options{num_nodes});
        }
    }
    elsif ( $remainder != 0 ) {
        dprintf( "Calculating proper npernode due to uneven division of numranks/numnodes...\n" );
        $options{npernode} = -1 * floor($options{num_ranks} 
                                / $options{num_nodes});
    }
    # recalculate num_ranks in case user specified -N which is less than 
    # rm_num_nodes.  if npernode is negative though, leave it alone since
    # an imbalance of ranks per node can only occur if the user specified
    # num_ranks explicitly already
    if ( $options{npernode} > 0 ) {
        my $recalculated_ranks = $options{num_nodes} * $options{npernode};
        if ( $options{num_ranks} != $recalculated_ranks ) {
            dprintf( "Will use %d ranks instead of the previous %d\n",
                $recalculated_ranks,
                $options{num_ranks} );
        }
        $options{num_ranks} = $recalculated_ranks;
    }

    ### Check the sanity of the inputted parameters
    if ( $options{npernode} > $options{sys_ppn} ) 
    {
        # don't bail here; some codes have a lightweight management rank that 
        # in addition to the one-rank-per-core compute ranks
        printf( STDERR 
            "WARNING: Your job will put more ranks on each node (%d) than the "
            ."cores physically available to each node (%d)\n",
            $options{npernode}, $options{sys_ppn} );
    }

    if ( $options{num_nodes} > $options{sys_max_nodes} )
    {
        bailout(3, sprintf("ERROR: Your job requests more nodes (%d) than the "
            ."maximum allowed per job (%d)\n",
            $options{num_nodes},
            $options{sys_max_nodes} ),
            $options);
    }

    ### at this point, num_ranks, num_nodes, and npernode are guaranteed to 
    ### exist and be well-defined at this point
    return \%options;
}

################################################################################
### bailout: terminate with an error and optionally delete the temporary 
### nodefile created by ibrun
################################################################################
sub bailout
{
    my $errno = shift;
    my $errmsg = shift;
    print STDERR $errmsg;

    ### Delete temporary nodefile on error
    if ( $options
    &&   $options->{rm_nodefile}
    &&   $options->{nodefile}
    &&   $options->{nodefile} ne $options->{rm_nodefile}
    &&  -e $options->{nodefile} )
    {
        unlink $options->{nodefile};
    }

    exit $errno;
}

################################################################################
### dprintf: print messages if debugging is enabled
################################################################################
sub dprintf
{
    return unless ENABLE_DEBUGGING;
    printf( @_ );
}

__END__

=pod

=head1 NAME

ibrun - launch MPI jobs from an implementation-independent command

=head1 DESCRIPTION

This application launches an MPI job using a simple user interface that automatically configures the implementation- and system-specific features on whichever MPI stack the user wants to use.

-n, -np <n>
    launch n MPI ranks (default: use all cores provided by resource manager)

-o, --offset <n>
    assign MPI ranks starting at the nth slot provided by the resource manager
    (default: 0)

--npernode <n>
    only launch n MPI ranks per node

-h 
    print this message

=head1 KNOWN BUGS

No known issues.

=head1 AUTHOR

Glenn K. Lockwood (glock@sdsc.edu)

=cut
